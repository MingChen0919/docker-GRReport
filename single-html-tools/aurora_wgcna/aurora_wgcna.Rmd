---
title: 'WGCNA: gene co-expression network module discovery.'
output:
    html_document:
      number_sections: true
      toc: true
      theme: cosmo
      highlight: tango
---

```{r setup, include=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(
  echo = ECHO
)
```

```{r}
str(opt)
```

# Import data

Each row represents a gene and each column represents a sample.

```{r}
expression_data = read.csv(opt$X_e, header = TRUE, row.names = 1)
```

Display the first 100 genes.

```{r}
table_data = head(expression_data, 100)
datatable(table_data, options = list(), class = "display",
          callback = JS("return table;"), rownames(table_data), colnames(table_data), caption = NULL,
          filter = c("none", "bottom", "top"), escape = TRUE,
          style = "default", width = NULL, height = NULL, elementId = NULL,
          fillContainer = getOption("DT.fillContainer", NULL),
          autoHideNavigation = getOption("DT.autoHideNavigation", NULL),
          selection = c("multiple", "single", "none"), extensions = list(),
          plugins = NULL, editable = FALSE)
```

Transpose expression data matrix so that each row represents a sample and each column represents a gene.

```{r}
expression_data = as.data.frame(t(expression_data))
```

# Checking data

Checking data for excessive missing values and identification of outlier microarray samples.

```{r}
gsg = goodSamplesGenes(expression_data, verbose = 3)
if (!gsg$allOK) {
  # Optionally, print the gene and sample names that were removed:
  if (sum(!gsg$goodGenes)>0)
    printFlush(paste("Removing genes:", paste(names(expression_data)[!gsg$goodGenes], collapse = ", ")));
  if (sum(!gsg$goodSamples)>0)
    printFlush(paste("Removing samples:", paste(rownames(expression_data)[!gsg$goodSamples], collapse = ", ")));
  # Remove the offending genes and samples from the data:
  expression_data = expression_data[gsg$goodSamples, gsg$goodGenes]
} else {
  print('all genes are OK!')
}
```

# Clustering samples

If there are any outliers, choose a height cut that will remove the offending sample. Remember this number since you will need this number in further analysis.

```{r fig.align='center'}
sampleTree = hclust(dist(expression_data), method = "average");
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="",
     cex.axis = 1, cex.main = 1, cex = 0.5)
```


# Processing outliers {.tabset}

## Before removing outliers

```{r}
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="",
   cex.lab = 1.5, cex.axis = 1, cex.main = 1, cex = 0.5)

if(!is.na(opt$X_h)) {
  # plot a line to show the cut
  abline(h = opt$X_h, col = "red")
  clust = cutreeStatic(sampleTree, cutHeight = opt$X_h, minSize = 10)
  keepSamples = (clust==1)
}
else {
  # determine cluster under the line
  clust = cutreeDynamic(sampleTree, method="tree"), minClusterSize = 10)
  keepSamples = (clust!=0)
}
expression_data = expression_data[keepSamples, ]
```

## After removing outliers

```{r}
sampleTree = hclust(dist(expression_data), method = "average");
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="",
     cex.axis = 1, cex.main = 1, cex = 0.5)
```


# Trait data {.tabeset}

If trait data is provided, the first 100 rows from the data will be displayed here. A plot consisting of sample cluster dendrogram and trait heatmap will also be gerenated.

## Trait data table

```{r}
trait_data = data.frame()
if ("TRAIT_DATA" != 'None') {
  trait_data = read.csv(opt$X_t, header = TRUE, row.names = 1)

  # Form a data frame analogous to expression data that will hold the traits.
  sample_names = rownames(expression_data)
  trait_rows = match(sample_names, rownames(trait_data))
  trait_data = trait_data[trait_rows, ]

  datatable(trait_data, options = list(), class = "display",
            callback = JS("return table;"), rownames(trait_data), colnames(trait_data), caption = NULL,
            filter = c("none", "bottom", "top"), escape = TRUE,
            style = "default", width = NULL, height = NULL, elementId = NULL,
            fillContainer = getOption("DT.fillContainer", NULL),
            autoHideNavigation = getOption("DT.autoHideNavigation", NULL),
            selection = c("multiple", "single", "none"), extensions = list(),
            plugins = NULL, editable = FALSE)

}
```

## Dendrogram and heatmap

```{r fig.align='center', fig.width=8, fig.height=9}
if (nrow(trait_data) != 0) {
  # Determine the column types within the trait annotation data.
  trait_types = sapply(trait_data, class)

  # Set the colors for the quantitative data.
  quantitative_fields = which(trait_types == "numeric")
  quantitative_colors = numbers2colors(trait_data[,quantitative_fields], signed = FALSE)
  colnames(quantitative_colors) = colnames(trait_data[,quantitative_fields])

  # Set the colors for the categorical data.
  categorical_fields = which(trait_types == "factor")
  categorical_colors = labels2colors(trait_data[,categorical_fields])
  colnames(categorical_colors) = colnames(trait_data[,categorical_fields])

  # Set the colors for the ordinal data.
  ordinal_fields = which(trait_types == "integer")
  ordinal_colors = numbers2colors(trait_data[,ordinal_fields], signed = FALSE)
  colnames(ordinal_colors) = colnames(trait_data[,ordinal_fields])

  # Combine the colors in their original order as the trait_data data frame.
  traitColors = cbind(quantitative_colors, categorical_colors, ordinal_colors)
  traitColors = traitColors[,colnames(trait_data)]

  plotDendroAndColors(sampleTree, traitColors,
                      groupLabels = names(trait_data),
                      main = "Sample dendrogram and trait heatmap",
                      cex.dendroLabels = 0.5)
}
```


# The thresholding power

```{r}
powers = c(1:10, seq(12, 20, 2))
sft = pickSoftThreshold(expression_data, powerVector = powers, verbose = 5)
```

```{r fig.align='center'}
par(mfrow=c(1,2))

# Scale-free topology fit index as a function of the soft-thresholding power.
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",
     ylab="Scale Free Topology Model Fit,signed R^2", type="n",
     main = paste("Scale independence"), cex.lab = 0.5);
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=0.5,col="red");

# Mean connectivity as a function of the soft-thresholding power.
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"), cex.lab = 0.5)
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=0.5,col="red")
par(mfrow=c(1,1))
```


# Construct network

The gene network is constructed based on **soft threshold power = `r soft_threshold_power`**

```{r}
net = blockwiseModules(expression_data, power = sft$powerEstimate,
                      TOMType = "unsigned", minModuleSize = 30,
                      reassignThreshold = 0, mergeCutHeight = 0.25,
                      numericLabels = TRUE, pamRespectsDendro = FALSE,
                      verbose = 3)
```


# Gene modules {.tabset}

## Idenfity gene modules

```{r}
module_labels = labels2colors(net$colors)
module_labels = paste("ME", module_colors, sep="")
modules = as.data.frame(table(module_labels))
n_modules = length(modules) - 1
module_size_upper = modules[2]
module_size_lower = modules[length(modules)]
colnames(modules) = c('Module', 'Module Size')
datatable(modules)
```

The results above indicates that there are **`r n_modules` gene modules**, labeled 1 through `r length(n_modules)` in order of descending size. The largest module has **`r module_size_upper` genes**, and the smallest module has **`r module_size_lower` genes**. The label 0 is reserved for genes outside of all modules.


## Dendrogram and module plot

```{r}
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(net$dendrograms[[1]], net$colors[net$blockGenes[[1]]],
                    "Module colors", dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)
```


# Gene module correlation

We can calculate eigengenes and use them as representative profiles to quantify similarity of found gene modules.

```{r}
n_genes = ncol(expression_data)
n_samples = nrow(expression_data)
```

```{r}
TOM = TOMsimilarityFromExpr(expression_data, power = sft$powerEstimate)
diss_tom = 1-TOM
set.seed(123)
select_genes = sample(n_genes, size = 1000)
select_diss_tom = diss_tom[select_genes, select_genes]

# calculate gene tree on selected genes
select_gene_tree = hclust(as.dist(select_diss_tom), method = 'average')
select_module_colors = module_colors[select_genes]

# transform diss_tom with a power to make moderately strong connections more visiable in the heatmap.
plot_diss_tom = select_diss_tom^7
# set diagonal to NA for a nicer plot
diag(plot_diss_tom) = NA
```


```{r fig.align='center'}
TOMplot(plot_diss_tom, select_gene_tree, select_module_colors, main = "Network heatmap")
```


# Eigengene visualization {.tabset}

## Eigengene dendrogram

```{r fig.align='center'}
module_eigengenes = moduleEigengenes(expression_data, module_colors)$eigengenes
plotEigengeneNetworks(module_eigengenes, "Eigengene dendrogram",
                      plotHeatmaps = FALSE)
```

## Eigengene adjacency heatmap

```{r fig.align='center'}
plotEigengeneNetworks(module_eigengenes, "Eigengene adjacency heatmap",
                      marHeatmap = c(2, 3, 2, 2),
                      plotDendrograms = FALSE, xLabelsAngle = 90)
```

# Labeled Heatmap
MEs = orderMEs(module_eigengenes)
moduleTraitCor = cor(MEs, trait_data, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, n_samples);

```{r fig.align='center'}
textMatrix = paste(signif(moduleTraitCor, 2), "\n(", signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(6, 8.5, 3, 3));

# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
  xLabels = names(trait_data),
  yLabels = names(MEs),
  ySymbols = names(MEs),
  colorLabels = FALSE,
  colors = blueWhiteRed(50),
  textMatrix = textMatrix,
  setStdMargins = FALSE,
  cex.text = 0.5,
  zlim = c(-1,1),
  main = paste("Module-trait relationships"))
```

```{r}
# names (colors) of the modules
modNames = substring(names(MEs), 3)
geneModuleMembership = as.data.frame(cor(expression_data, MEs, use = "p"));
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), n_samples));
names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="");

# Calculate the gene trait significance as a Pearson's R and p-value.
xdata =  as.data.frame(trait_data[[x]]);
gts = as.data.frame(cor(expression_data, trait_data, use = "p"));
gtsp = as.data.frame(corPvalueStudent(as.matrix(gts), n_samples));
colnames(gtsp) = c(paste("p", names(trait_data), sep="."))
colnames(gts) = c(paste("GS", names(trait_data), sep="."))

```

# Write out the output file

```{r}
# Write out the gene information.
output = cbind(Module = module_labels, gts, gtsp)
write.csv(output, file = "wgcna_analysis.genes.csv", quote=FALSE, row.names=TRUE)

```
